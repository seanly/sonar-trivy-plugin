package org.sonarsource.plugins.trivy;

import org.sonarsource.plugins.trivy.config.TrivyVulnerabilityRulesDefinition;
import org.sonarsource.plugins.trivy.model.TrivyData;
import org.sonar.api.batch.fs.FileSystem;
import org.sonar.api.batch.fs.InputFile;
import org.sonar.api.batch.sensor.Sensor;
import org.sonar.api.batch.sensor.SensorContext;
import org.sonar.api.batch.sensor.SensorDescriptor;
import org.sonar.api.batch.sensor.issue.NewIssue;
import org.sonar.api.batch.sensor.issue.NewIssueLocation;
import org.sonar.api.rule.RuleKey;
import org.sonar.api.utils.log.Logger;
import org.sonar.api.utils.log.Loggers;

import java.io.File;
import java.util.List;

/**
 * Trivy Vulnerability Sensor for processing Trivy vulnerability reports in SARIF format
 */
public class TrivyVulnerabilitySensor implements Sensor {

    private static final Logger LOGGER = Loggers.get(TrivyVulnerabilitySensor.class);
    
    // Configuration keys
    public static final String TRIVY_SARIF_FILE_PATH = "trivy.sarif.file.path";
    public static final String DEFAULT_TRIVY_SARIF_FILE_PATH = "trivy-report.sarif";
    
    // Rule keys for different severity levels
    public static final String TRIVY_CRITICAL_RULE = "critical";
    public static final String TRIVY_HIGH_RULE = "high";
    public static final String TRIVY_MEDIUM_RULE = "medium";
    public static final String TRIVY_LOW_RULE = "low";

    @Override
    public void describe(SensorDescriptor descriptor) {
        descriptor.name("Trivy Vulnerability Sensor");
    }

    @Override
    public void execute(SensorContext context) {
        LOGGER.info("Starting Trivy vulnerability analysis");
        
        try {
            // Get Trivy SARIF file path from configuration
            String trivySarifFilePath = context.config().get(TRIVY_SARIF_FILE_PATH).orElse(DEFAULT_TRIVY_SARIF_FILE_PATH);
            File trivySarifFile = new File(trivySarifFilePath);
            
            if (!trivySarifFile.exists()) {
                LOGGER.warn("Trivy SARIF file not found: {}", trivySarifFile.getAbsolutePath());
                return;
            }
            
            // Parse Trivy SARIF file
            TrivyProcessor processor = new TrivyProcessor();
            List<TrivyData> trivyDataList = processor.parseTrivySarifFile(trivySarifFile);
            
            if (trivyDataList.isEmpty()) {
                LOGGER.info("No vulnerabilities found in Trivy SARIF file");
                return;
            }
            
            // Create issues for each vulnerability
            createIssuesFromTrivyData(context, trivyDataList);
            
            LOGGER.info("Successfully processed {} vulnerabilities from Trivy SARIF file", trivyDataList.size());
            
        } catch (Exception e) {
            LOGGER.error("Error processing Trivy SARIF file: {}", e.getMessage(), e);
        }
    }
    
    private void createIssuesFromTrivyData(SensorContext context, List<TrivyData> trivyDataList) {
        FileSystem fs = context.fileSystem();
        
        for (TrivyData trivyData : trivyDataList) {
            try {
                createIssue(context, fs, trivyData);
            } catch (Exception e) {
                LOGGER.error("Error creating issue for vulnerability {}: {}", 
                           trivyData.getRuleId(), e.getMessage(), e);
            }
        }
    }
    
    private void createIssue(SensorContext context, FileSystem fs, TrivyData trivyData) {
        // Determine rule key based on severity
        RuleKey ruleKey = getRuleKeyForSeverity(trivyData.getSeverity());
        
        LOGGER.debug("Creating issue for vulnerability {} with file path: {}", 
                    trivyData.getRuleId(), trivyData.getFilePath());
        
        // Find the source file
        InputFile sourceFile = findSourceFile(fs, trivyData.getFilePath());
        if (sourceFile == null) {
            LOGGER.warn("Source file not found for vulnerability {}: {}", 
                        trivyData.getRuleId(), trivyData.getFilePath());
            return;
        }
        
        LOGGER.debug("Found source file: {} for vulnerability: {}", 
                    sourceFile.filename(), trivyData.getRuleId());
        
        // Create the issue
        NewIssue newIssue = context.newIssue()
                .forRule(ruleKey)
                .gap(5.0); // Default gap
        
        // Create location
        NewIssueLocation location = newIssue.newLocation()
                .on(sourceFile)
                .at(sourceFile.selectLine(trivyData.getStartLine()))
                .message(createIssueMessage(trivyData));
        
        newIssue.at(location);
        newIssue.save();
        
        // Only after successful creation, add to TrivyDataStore
        TrivyDataStore.instance().addTrivyData(trivyData);
        
        LOGGER.info("Created issue for vulnerability {} in file {} at line {}", 
                    trivyData.getRuleId(), sourceFile.filename(), trivyData.getStartLine());
    }
    
    private RuleKey getRuleKeyForSeverity(String severity) {
        if (severity == null) {
            return RuleKey.of("trivy", TRIVY_HIGH_RULE);
        }
        
        switch (severity.toLowerCase()) {
            case "critical":
                return RuleKey.of("trivy", TRIVY_CRITICAL_RULE);
            case "high":
                return RuleKey.of("trivy", TRIVY_HIGH_RULE);
            case "medium":
                return RuleKey.of("trivy", TRIVY_MEDIUM_RULE);
            case "low":
                return RuleKey.of("trivy", TRIVY_LOW_RULE);
            default:
                return RuleKey.of("trivy", TRIVY_HIGH_RULE);
        }
    }
    
    private InputFile findSourceFile(FileSystem fs, String filePath) {
        if (filePath == null || filePath.isEmpty()) {
            LOGGER.debug("File path is null or empty");
            return null;
        }
        
        LOGGER.debug("Looking for file: {}", filePath);
        
        // Normalize file path
        String normalizedPath = filePath.replace("\\", "/");
        String fileName = new File(filePath).getName();
        
        LOGGER.debug("Normalized path: {}, File name: {}", normalizedPath, fileName);
        
        // Try multiple predicates to find the file
        // First try with all files
        InputFile foundFile = findFileWithPredicate(fs, filePath, fs.predicates().all(), "all files");
        if (foundFile != null) {
            return foundFile;
        }
        
        // Try with main files only
        foundFile = findFileWithPredicate(fs, filePath, fs.predicates().hasType(InputFile.Type.MAIN), "main files");
        if (foundFile != null) {
            return foundFile;
        }
        
        // Try with test files
        foundFile = findFileWithPredicate(fs, filePath, fs.predicates().hasType(InputFile.Type.TEST), "test files");
        if (foundFile != null) {
            return foundFile;
        }
        
        // Try with just the filename if path matching failed
        LOGGER.debug("Trying to find file by name only: {}", fileName);
        foundFile = findFileByName(fs, fileName);
        if (foundFile != null) {
            return foundFile;
        }
        
        LOGGER.warn("File not found in SonarQube filesystem: {}", filePath);
        return null;
    }
    
    private InputFile findFileByName(FileSystem fs, String fileName) {
        for (InputFile inputFile : fs.inputFiles(fs.predicates().all())) {
            if (inputFile.filename().equals(fileName)) {
                LOGGER.debug("Found file by name: {} -> {}", fileName, inputFile.relativePath());
                return inputFile;
            }
        }
        return null;
    }
    
    private InputFile findFileWithPredicate(FileSystem fs, String filePath, org.sonar.api.batch.fs.FilePredicate predicate, String predicateName) {
        LOGGER.debug("Searching with predicate: {}", predicateName);
        int fileCount = 0;
        
        // Normalize the search path
        String normalizedSearchPath = filePath.replace("\\", "/");
        String searchFileName = new File(filePath).getName();
        
        for (InputFile inputFile : fs.inputFiles(predicate)) {
            fileCount++;
            String inputFileUri = inputFile.uri().toString();
            String inputFileName = inputFile.filename();
            String inputFilePath = inputFile.relativePath();
            String normalizedInputPath = inputFilePath.replace("\\", "/");
            
            LOGGER.debug("Checking file {}: filename={}, path={}, uri={}", 
                        fileCount, inputFileName, inputFilePath, inputFileUri);
            
            // Enhanced matching: check multiple criteria
            if (inputFileName.equals(searchFileName) || 
                inputFileName.equals(filePath) ||
                inputFilePath.equals(filePath) ||
                normalizedInputPath.equals(normalizedSearchPath) ||
                inputFileUri.contains(filePath) ||
                inputFileUri.endsWith(filePath) ||
                inputFileUri.contains(searchFileName) ||
                inputFilePath.endsWith(searchFileName)) {
                
                LOGGER.debug("Found matching file in SonarQube filesystem: {} for path: {} using predicate: {}", 
                            inputFileName, filePath, predicateName);
                return inputFile;
            }
        }
        
        LOGGER.debug("Searched {} files with predicate '{}', no match found for: {}", fileCount, predicateName, filePath);
        return null;
    }
    
    private String createIssueMessage(TrivyData trivyData) {
        StringBuilder message = new StringBuilder();
        
        if (trivyData.getPackageName() != null && !trivyData.getPackageName().isEmpty()) {
            message.append("Package: ").append(trivyData.getPackageName());
        }
        
        if (trivyData.getInstalledVersion() != null && !trivyData.getInstalledVersion().isEmpty()) {
            if (message.length() > 0) {
                message.append(" | ");
            }
            message.append("Version: ").append(trivyData.getInstalledVersion());
        }
        
        if (trivyData.getFixedVersion() != null && !trivyData.getFixedVersion().isEmpty()) {
            if (message.length() > 0) {
                message.append(" | ");
            }
            message.append("Fixed in: ").append(trivyData.getFixedVersion());
        }
        
        if (message.length() == 0) {
            message.append(trivyData.getMessage());
        }
        
        return message.toString();
    }
} 